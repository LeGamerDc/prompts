---
name: codex
description: 帮助主 Agent 将特定编程问题委派给 Codex CLI 的独立子进程（Subagent）执行。通过物理隔离（Subagent/Headless进程）来实现上下文和复杂度的降维，并利用高配推理模型解决纯计算、逻辑闭环且非平凡的编程问题。
---

# Codex Subagent Skill

将封闭的编码子任务以 Subagent 的形式路由给 Codex CLI 无头模式（Headless）执行，降低 Claude/Gemini 使用成本并利用独立高配模型（gpt-5.3-codex）强大的推理能力。主 Agent 专注于规划、架构和需要广泛上下文的工作；Codex 处理独立自包含的实现问题。

## 1. 委派条件 (Trigger Conditions)

**主 Agent 在遇到子任务时，必须评估是否满足以下全部委派条件。只有全部满足时，才允许调用本 Skill。**

1. **接口明确**：可以定义出清晰的函数签名、输入类型、输出类型和错误边界。
2. **完全自包含（无外部依赖）**：不依赖项目其他模块的运行时状态或内部复杂的类型体系。
3. **可独立测试**：能够通过编写一段独立的测试代码（或使用现有测试框架）来清晰验证正确性。
4. **非平凡（有一定复杂度）**：具有一定的算法/逻辑复杂度（如：算法实现、数据结构操作、数学/物理计算、解析器、编解码器、正则表达式、状态机、纯函数工具等），值得走委派逻辑。

**【反向约束：绝对不要委派】**
- 涉及外部 API 调研。
- 需要多模块协调和修改。
- 业务逻辑重构。
- 需要主观的 UI/UX 或系统架构设计决策。

## 2. 问题建模 (Prompt Modeling)

在调用 Codex 之前，必须将子任务准确描述并构建为一个完整的 Prompt 文本（Markdown 格式）。
Prompt 核心元素必须包含以下六项：

```markdown
### 任务描述
[清楚说明做什么，解决什么具体问题]

### 实现位置
[必须精确指定实现的文件路径，以及函数名/类名]

### 编程语言
[实现所用的编程语言]

### 接口定义
[明确给出函数签名：参数列表及其类型、返回类型、预期的异常/错误处理约定]

### 核心约束
[性能要求（如时间/空间复杂度）、边界条件（Corner Cases）、特殊规则、以及**强制不修改不相关代码的约束**]

### 测试要求
[测试文件的具体路径，必须覆盖哪些用例。Codex 将负责实现代码并通过测试，以测试用例是否通过作为任务成功的唯一标准]

### 最小化上下文（可选但推荐）
[如果实现依赖某些已有的类型定义或接口桩代码(Stub/Mock)，请在这里提供最小化的定义，不要给全局上下文。]
```

## 3. 执行委派 (Execution)

使用 `run_shell_command` 执行 Codex 命令行工具完成任务。这是一个自动化的 Subagent，它将完全自主工作。

**始终使用以下固定参数执行：**
- **模型**：`gpt-5.3-codex`
- **推理强度**：`xhigh`
- **沙盒权限**：`workspace-write`
- **静默审批**：`never`（从配置中覆盖）

**推荐的 Shell 调用格式（使用 Here Doc）：**

```bash
codex exec -m gpt-5.3-codex -c model_reasoning_effort=xhigh -c approval_policy=never -s workspace-write - << 'EOF'
这里填入你在第2步构建好的【问题建模 Prompt】
EOF
```

## 4. 验证与兜底处理 (Verification & Fallback)

- **成功确认**：Codex 执行完毕后，必须检查目标实现文件和测试文件是否已被正确写入，并运行测试命令来验证结果。如果测试通过，任务即视为成功完成，继续执行主 Agent 的下一步计划。
- **失败兜底（禁止重试）**：如果 Codex 返回错误、超时、代码未通过测试或者无法闭环，这通常意味着任务描述不清晰或超出了纯计算的范畴。**主 Agent 必须直接自己接手完成该任务，绝对不要进行任何形式的 Codex 重试。**
