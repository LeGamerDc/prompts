# 开发工作流

## 触发条件

`project/arch.md` 和 `project/dev-plan.md` 存在，用户要求执行某个开发任务、实现功能、写代码。

## 工作流程

### 1. 定位任务

从 `dev-plan.md` 中定位本次要执行的任务：

- 用户指定了任务 ID → 直接定位
- 用户描述了要做的功能 → 在任务列表中匹配
- 用户未明确 → 根据依赖关系和阶段，推荐下一个可执行的任务

确认后，将该任务状态更新为「进行中」。

### 2. 按清单载入文档

按任务详情中的「需读取文档」清单载入（优先使用 subagent 并行读取）：

**始终载入：**
- 任务详情中列出的所有文档
- 对应的 `code-structure/` 文档（理解目录结构和已有代码位置）
- `conventions/coding.md`（确保代码风格一致）

**按需补充：**
- `conventions/error-handling.md`（涉及错误处理时）
- `testing/strategy.md`（需要写测试时）
- 相关模块的 memory（了解历史决策和技术债务）

### 3. 搜索已有代码

**实现任何功能前，先搜索项目中是否已有可复用的代码：**

1. 查阅 `code-structure/` 文档的「公共模块与工具库」章节，了解已有工具和共享代码
2. 按 `code-structure/` 中的「新增代码定位指南」确定新代码的放置位置
3. 在代码库中搜索相似功能（函数名、类名、关键词）
4. 如果找到可复用的代码 → 直接引用，不要重新实现
5. 如果找到部分相似的代码 → 考虑抽取为公共工具后复用

### 4. 子任务拆解

将任务进一步拆解为实现步骤：

```markdown
## 实现计划: <任务名>

### 前置检查
- [ ] 依赖任务已完成（检查 dev-plan.md）
- [ ] 已搜索并确认没有可直接复用的已有实现

### 实现步骤
1. [ ] <具体的、可验证的步骤>
2. [ ] <...>

### 验收标准（来自 dev-plan.md）
- [ ] <逐条列出>
```

### 5. Subagent 拆分策略

评估步骤的依赖关系，尽可能并行执行：

**可并行的场景：**
- 前端和服务端的同一功能模块（互不依赖的部分）
- 多个独立文件的创建或修改
- 实现代码 + 编写测试（当接口已确定时）

**必须串行的场景：**
- 接口定义 → 接口实现（先定义后实现）
- 核心模块 → 依赖模块（先核心后外围）
- 协议修改 → 前后端适配（先协议后代码）

**Subagent 任务描述模板：**
```
任务: <具体任务>
相关文档: <需要读取的文件路径列表>
架构约束: <必须遵守的设计决策>
编码规范: <关键的规范要点>
已有代码: <可复用的已有代码路径>
验收标准: <完成的判断条件>
```

### 6. 实现

执行步骤时遵循：

1. **搜索优先**：实现每个函数/模块前，先搜索是否已有类似实现
2. **先读后写**：修改已有文件前先通读，理解上下文
3. **对照文档**：代码必须与 architecture 文档和 GDD 设计一致
4. **遵循规范**：按 `conventions/` 中的规范编写代码
5. **正确定位**：新文件放在 `code-structure/` 文档指定的位置
6. **写测试**：按 `testing/strategy.md` 的要求编写测试

### 7. 自检

实现完成后，对照验收标准逐条自检：

- [ ] dev-plan.md 中该任务的验收标准是否全部满足？
- [ ] 代码是否符合 `conventions/coding.md`？
- [ ] 代码位置是否与 `code-structure/` 文档一致？
- [ ] 是否与 `architecture/` 中的设计一致？
- [ ] 协议消息是否与 `.proto` 定义一致？（涉及通信时）
- [ ] 有没有引入技术债务？如有，记录到 memory
- [ ] 测试是否通过？覆盖是否足够？
- [ ] 是否新增了可复用的公共代码？如有，更新 `code-structure/` 文档

### 8. 更新状态

实现完成后更新：
- `dev-plan.md` — 该任务状态改为「已完成」
- `memory/project.md`「模块进度」
- `memory/modules/<module>.md`「状态」和「决策历史」
- `gdd-mapping.md`「状态」列
- `code-structure/` — 如果新增了公共代码或目录结构变化
- 如果引入了技术债务 → `memory/project.md`「技术债务」

## 特殊场景

### Bug 修复

1. 复现并理解问题
2. 定位相关文档（架构 + GDD）确认预期行为
3. 分析根因
4. 修复并验证
5. 如果 bug 暴露了架构问题 → 记录到 memory「待解决」

### 重构

1. 明确重构的动机和范围
2. 检查是否与架构文档一致（重构后应该更接近设计）
3. 确保有足够测试覆盖再重构
4. 重构后更新相关的 `code-structure/` 文档
5. 更新 memory 记录重构决策

### 协议变更

1. 先修改 `architecture/protocols/overview.md` 说明变更意图
2. 更新 `.proto` 定义
3. 用 subagent 并行更新前端和服务端适配代码
4. 更新相关测试
5. 记录到 memory
