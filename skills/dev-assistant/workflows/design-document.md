# 设计文档工作流

## 创建新文档

1. 确认目标文档类型（tech-stack / architecture / code-structure / testing / conventions）
2. 从项目 memory 中提取已有决策作为基础
3. 对照 GDD 文档确保技术方案服务于设计目标
4. 使用下方对应模板创建文档
5. 创建后更新 `arch.md` 索引（添加链接和摘要）

## 文档模板

### 技术栈文档（`tech-stack/*.md`）

```markdown
# <前端/服务端/工具链> 技术栈

## 选型结果

| 类别 | 选择 | 版本 |
|------|------|------|
| <语言/引擎/框架/...> | <名称> | <版本> |

## 选型理由

### <选择项 1>
- **为什么选它**: <核心理由>
- **对齐的设计需求**: <关联的 GDD 设计支柱或系统需求>
- **考虑过的替代方案**: <方案及放弃原因>
- **已知限制**: <已知的不足和应对策略>

## 版本策略
<依赖更新策略、锁定策略>
```

### 架构文档（`architecture/*.md`）

```markdown
# <前端/服务端> 架构

## 概述
架构风格和核心设计思路。与 GDD 设计目标的关联。

## 架构图
<ASCII 图或 Mermaid 描述整体架构>

## 核心模块

### <模块名>
- **职责**: <做什么>
- **对应 GDD**: <关联的游戏系统>
- **对外接口**: <暴露的接口>
- **依赖**: <依赖的其他模块>

## 数据流
<关键数据流描述>

## 关键设计决策
- **决策**: <内容> | **理由**: <为什么> | **权衡**: <放弃了什么>

## 性能考量
<性能热点、优化策略、性能预算>

## 开放问题
尚未确定的设计点，标注优先级。
```

### 协议文档（`architecture/protocols/overview.md`）

```markdown
# 通信协议设计

## 协议概述
- 格式: Protobuf
- 传输: <WebSocket/HTTP/...>
- 编码: <binary/JSON 降级策略>

## 版本策略
<协议版本管理、向后兼容策略>

## 消息分类

| 类别 | 方向 | 说明 | Proto 文件 |
|------|------|------|-----------|
| <类别名> | C→S / S→C / 双向 | <说明> | <文件名.proto> |

## 错误处理
<协议层的错误码体系、重试策略>

## 安全考量
<认证、加密、防作弊相关>
```

### 数据模型文档（`architecture/data-model.md`）

```markdown
# 数据模型设计

## 概述
数据模型的整体设计思路和存储策略。

## 核心实体

### <实体名>
- **用途**: <描述>
- **存储**: <内存/数据库/配置文件>
- **生命周期**: <创建→使用→销毁的时机>
- **关联**: <与其他实体的关系>

## 配置数据
<游戏配置数据的格式、加载策略、热更新支持>

## 存档/持久化
<存档格式、存储位置、备份策略>

## 数据一致性
<客户端-服务端数据同步策略、冲突解决>
```

### 代码结构文档（`code-structure/*.md`）

> 代码结构文档是开发阶段的「地图」——后续 agent 按此文档定位代码位置、查找已有工具、确定新代码放置位置。务必详细且准确。

```markdown
# <前端/服务端> 代码结构

## 目录总览

```
src/
├── <dir>/          # <说明>
│   ├── ...
```

## 模块划分原则
<按什么维度拆分模块：功能/层级/领域>

## 模块详情

### <模块名>（`<路径>`）
- **职责**: <做什么>
- **对外暴露**: <公开接口——函数签名、类、类型>
- **内部结构**: <关键文件说明>
- **依赖**: <依赖哪些其他模块>

## 公共模块与工具库

### 工具函数（`<路径，如 src/utils/>`）

| 工具 | 文件 | 说明 |
|------|------|------|
| <工具名> | <文件路径> | <用途和使用场景> |

> 新增工具函数时，先查阅此表确认是否已有类似工具。按功能分类放入对应文件，避免创建过多小文件。

### 共享类型定义（`<路径，如 src/types/>`）
<跨模块共享的类型、接口、枚举、常量定义及其文件组织>

### 共享算法/逻辑（`<路径>`）
<可复用的算法或业务逻辑，如随机算法、公式计算、数据转换等>

## 模块间接口约定

| 调用方 | 被调用方 | 接口 | 说明 |
|--------|---------|------|------|
| <模块A> | <模块B> | <函数/方法/事件> | <调用场景> |

## 新增代码定位指南

添加新功能时，按以下规则确定代码位置：

| 新增内容 | 放置位置 | 说明 |
|----------|---------|------|
| 新游戏系统 | `<路径规则>` | <说明> |
| 新工具函数 | `<路径规则>` | <说明> |
| 新类型定义 | `<路径规则>` | <说明> |
| 新协议处理 | `<路径规则>` | <说明> |
| 新配置定义 | `<路径规则>` | <说明> |

## 命名约定
<文件命名、模块命名、导出命名的规则>
```

### 测试策略文档（`testing/strategy.md`）

```markdown
# 测试策略

## 测试层级

| 层级 | 范围 | 工具 | 覆盖目标 |
|------|------|------|---------|
| 单元测试 | <范围> | <工具> | <覆盖率目标> |
| 集成测试 | <范围> | <工具> | <覆盖场景> |
| E2E 测试 | <范围> | <工具> | <关键路径> |

## 测试重点
<哪些模块/逻辑必须重点测试，关联 GDD 核心系统>

## 测试数据
<测试数据管理策略：fixture/factory/mock>

## CI 集成
<自动化测试在 CI 流程中的位置>
```

### 编码规范文档（`conventions/coding.md`）

```markdown
# 编码规范

## 通用规则
<缩进、行宽、文件组织等>

## 语言特定规则

### <语言 1>
<该语言的特定规范>

### <语言 2>
<该语言的特定规范>

## Lint / Format 工具
<使用的工具和配置>

## 代码审查标准
<什么情况下需要审查、审查关注点>
```

### 错误处理文档（`conventions/error-handling.md`）

```markdown
# 错误处理与日志规范

## 错误码体系

| 范围 | 模块 | 说明 |
|------|------|------|
| 1xxx | <模块> | <说明> |

## 错误处理策略
- 前端: <策略>
- 服务端: <策略>
- 协议层: <策略>

## 日志规范
- 级别: <DEBUG/INFO/WARN/ERROR 的使用场景>
- 格式: <日志格式>
- 存储: <日志存储和轮转策略>

## 监控告警
<关键指标和告警规则>
```

## 编辑现有文档

1. 载入相关 memory + 目标文档
2. 理解修改的上下文和原因
3. 执行修改
4. **修改后检查清单**：
   - [ ] 是否与 GDD 设计目标一致？
   - [ ] 是否与其他架构文档一致？
   - [ ] 是否影响通信协议定义？
   - [ ] 是否影响其他模块？需要更新对方文档吗？
   - [ ] `arch.md` 索引中的摘要是否需要更新？
5. 更新 memory：记录变更决策、日期、理由

## 拆分子文档

当文档超过大小上限，或某部分足够独立时：
1. 将该部分提取到新文件
2. 在原文档中保留**摘要**并添加引用链接
3. 更新 `arch.md` 索引
4. 更新 memory 记录结构变更

## 写作规范

- 使用明确、无歧义的语言
- 架构描述用图表辅助（ASCII 图或 Mermaid）
- 接口定义用代码片段呈现
- 区分「已确定」和「待讨论」的内容（后者用 `> [!TODO]` 标注）
- 每个重要设计决策标注 **设计意图**（为什么这样做）
- 保持与 GDD 术语一致（参考 `gdd/shared/glossary.md`）
