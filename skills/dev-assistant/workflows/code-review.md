# 代码评审工作流

## 触发条件

用户要求检查代码、评审实现、找问题。

## 工作流程

### 1. 确定评审范围

- 单个文件 / 单个模块 / 跨模块
- 新增代码 / 修改代码 / 重构代码
- 定位对应的架构文档和 GDD 系统

### 2. 载入上下文

**必读：**
- 被评审的代码文件
- 对应的 `architecture/` 文档（理解设计意图）
- `conventions/coding.md`（代码规范）

**按需读（使用 subagent 并行载入）：**
- 对应的 GDD 系统文档（验证需求实现完整性）
- `conventions/error-handling.md`（检查错误处理）
- `architecture/protocols/` 相关 `.proto`（验证协议一致性）
- `testing/strategy.md`（检查测试覆盖）
- 相关模块的 memory（了解历史决策）

### 3. 评审维度

**3.1 架构一致性**
- 代码结构是否与 `code-structure/` 文档一致？
- 模块职责是否与 `architecture/` 文档描述一致？
- 依赖方向是否正确（没有反向依赖或循环依赖）？
- 接口设计是否与架构文档中的定义匹配？

**3.2 GDD 需求完整性**
- 是否完整实现了 GDD 中描述的功能？
- 游戏逻辑是否与 GDD 设计一致（数值、规则、流程）？
- 边界情况是否处理（GDD 中的异常场景）？

**3.3 代码质量**
- 是否遵循 `conventions/coding.md` 中的规范？
- 命名是否清晰、一致？
- 逻辑是否清晰易读？有无过度复杂的部分？
- 是否有重复代码可以抽取？

**3.4 错误处理**
- 是否按 `conventions/error-handling.md` 规范处理错误？
- 错误码是否使用正确的范围？
- 异常路径是否有合理的降级或恢复策略？
- 日志是否充分且级别正确？

**3.5 性能**
- 有无明显的性能问题（N+1 查询、不必要的循环、内存泄漏）？
- 热路径代码（核心循环中的高频调用）是否足够高效？
- 是否有不必要的内存分配或拷贝？

**3.6 协议一致性**（涉及通信时）
- 消息结构是否与 `.proto` 定义一致？
- 序列化/反序列化是否正确？
- 错误响应是否符合协议约定？

**3.7 测试覆盖**
- 是否有对应的测试？覆盖是否符合 `testing/strategy.md`？
- 测试是否覆盖了关键路径和边界情况？
- 测试是否可靠（无随机失败、无环境依赖）？

### 4. Subagent 并行评审

对于大范围评审，用 subagent 并行检查不同维度：

- **Subagent 1**：架构一致性 + GDD 需求完整性（需读取架构和 GDD 文档）
- **Subagent 2**：代码质量 + 错误处理（需读取 conventions 文档）
- **Subagent 3**：性能 + 协议一致性（需读取 protocols 文档）

汇总后统一输出评审报告。

## 输出格式

```markdown
## 代码评审报告: <范围>
日期: YYYY-MM-DD

### 关键问题（必须修复）
- **问题**: 描述 | **文件**: 路径:行号 | **建议**: 修复方案

### 建议改进
- **问题**: 描述 | **文件**: 路径:行号 | **建议**: 改进方案

### 亮点
- 写得好的部分及原因

### 技术债务
- 发现的新技术债务

### GDD 偏差
- 实现与 GDD 设计不一致的地方
```

## 评审后操作

- 关键问题 → 立即修复或写入 memory「待解决」
- 技术债务 → 写入 `memory/project.md`「技术债务」
- GDD 偏差 → 与用户讨论是修改代码还是更新 GDD
- 更新 memory「回顾」记录
